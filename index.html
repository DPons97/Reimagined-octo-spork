<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ROS - Reimagined-Octo-Spork: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ROS - Reimagined-Octo-Spork
   </div>
   <div id="projectbrief">Heterogeneous distributed system for object tracking and fun stuff</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">ROS - Reimagined-Octo-Spork Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h4>Heterogeneous distributed system for object tracking and fun stuff</h4>
<p>This project involves object recognition with Darknet and OpenCV's YOLO algorithm running on a distributed system for object tracking.</p>
<h2>Requirements: </h2>
<p><b>Server-side</b>:</p>
<ul>
<li>**<a href="https://pjreddie.com/darknet/yolo/">Darknet YOLO</a>** (Already included in this repo) - <a href="https://github.com/pjreddie/darknet/">https://github.com/pjreddie/darknet/</a><ul>
<li>***.cfg** that are in this repository have been tweaked to be faster with less powerful NVIDIA GPUs*</li>
<li>***yolov3.weights** + <b>yolov3-tiny.weights</b> files are required and need to be placed inside **Server/darknet/***</li>
</ul>
</li>
</ul>
<p><b>Client-side:</b></p>
<ul>
<li><b>OpenCV 3.4.5</b> - <a href="https://github.com/opencv/opencv/releases/tag/3.4.5">https://github.com/opencv/opencv/releases/tag/3.4.5</a><ul>
<li><b>OpenCV_DNN</b> additional modules - <a href="https://github.com/opencv/opencv_contrib/releases/tag/3.4.5">https://github.com/opencv/opencv_contrib/releases/tag/3.4.5</a></li>
<li>Installation guide here: <a href="https://docs.opencv.org/3.2.0/de/d25/tutorial_dnn_build.html">https://docs.opencv.org/3.2.0/de/d25/tutorial_dnn_build.html</a></li>
<li>If you feel brave enough, you can try the automatic installation launching the script that you find inside this repo (it should download, compile the right version of OpenCV): ```bash sudo sh build_opencv.sh <code> **NB:** This script doesn't install OpenCV. After executing it, you still have to go to *opencv-3.4.5/build/* and</code>install```.<br/>
</li>
</ul>
</li>
<li>A <em>LOT</em> of patience</li>
</ul>
<h2>Installation: </h2>
<p>After cloning this repository (<code>git clone <a href="https://github.com/DPons97/reimagined-octo-spork.git">https://github.com/DPons97/reimagined-octo-spork.git</a></code>):</p>
<ul>
<li>Build darknet inside <code>Server/darknet/</code> (and test it!)<br/>
 Download and place darknet's weights in <b>Server/darknet/</b>: ```bash wget <a href="https://pjreddie.com/media/files/yolov3.weights">https://pjreddie.com/media/files/yolov3.weights</a> wget <a href="https://pjreddie.com/media/files/yolov3-tiny.weights">https://pjreddie.com/media/files/yolov3-tiny.weights</a> ```</li>
<li>Build OctoSpork: ```bash cd [...]/reimagined-octo-spork/ mkdir build cmake .. make [leave empty if you want to build everything. Otherwise, see below] <code> If you want to only build Server, change</code>make<code>line to: </code>shell make OctoSporkServer ``` Otherwise, to build Client only: ```shell make OctoSporkClient ```</li>
<li>If you decided to build Client, you must move and compile <em><a class="el" href="classbkgSubtraction.html" title="Instruction to perform background subtraction. ">bkgSubtraction</a></em> and <em>nodeTracker</em> inside ***Client/Executables***.</li>
</ul>
<h2>Running ROS: </h2>
<p>cd into the build directory in reimagined-octo-spork ```bash cd path-to/reimagined-octo-spork/build ```</p>
<ul>
<li>Server side: ```bash ./OctoSporkServer ```</li>
<li><p class="startli">Client side: There are two ways to run the client executable:</p>
<ul>
<li>Passing all information as arguments ```bash ./OctoSporkClient [ipaddress] [port] [node_id] [node_x] [node_y] [theta] [top_neighbour] [bottom_n] [left_n] [right_n] ```</li>
<li>Passing a configuration file ```bash ./OctoSporkClient [path_to_cfg_file] ``` The configuration file should be a one-line file with the arguments you would pass as above.</li>
</ul>
<p class="startli"><b>NB:</b> <em>node_x</em>, <em>node_y</em>, <em>theta</em> are respectively the coordinates and the phase displacement of the camera's node.</p>
</li>
</ul>
<p>Run ROS demo client:</p>
<ul>
<li>Node 1 (set cam1 in file path in <em>Client/Executables/</em> files) ```bash ./OctoSporkClient [ipaddress] 51297 1 0 0 0 3 4 5 2 ```</li>
<li>Node 2 (set cam2 in file path in <em>Client/Executables/</em> files) ```bash ./OctoSporkClient [ipaddress] 51297 2 0 0 260 7 8 1 9 ``` <br/>
</li>
</ul>
<h2>Tested Hardware: </h2>
<ul>
<li>Odroid xu4</li>
<li>Jetson-TX2 with Nvidia Tegra technology</li>
<li>Any PC with any Linux distribution (Tested on Fedora and Ubuntu) <br/>
<br/>
</li>
</ul>
<h2>The idea: </h2>
<p>The task for this project was to work on a framework for distributed software. Requirements included:</p>
<ul>
<li>Achieving a good level of customizability and scalability</li>
<li>Compatible with mobile CPUs (ARM 32bit) and embedded boards</li>
<li>Working demo of a case study using the framework</li>
</ul>
<p>The initial goal was to develop a peer to peer system with an external resource controller that would manage the load between the nodes.<br/>
 We took an incremental approach to the project and we first worked to build a simpler version with a client server architecture. We then realized that we could get a good result by improving our first version, and since time was running low, so we did.<br/>
 As we needed to work on a realistic case study, we thought about diving into image recognition and building a distributed tracking system.<br/>
 First, we did some research to find the algorithms we had at disposal and to select which one was the most suitable for our hardware.<br/>
 Pjreddie's darknet network is really good concerning detection and it's fast enough on the Jetson but, having to also use an Odroid XU4 (8 cores CPU, no GPU), YOLO's library would result in really high computational times.<br/>
 Here's where OpenCV's Deep Neural Network module comes in handy: it features a 9x faster implementation of DNN using CPU with the same darknet's yolov3 configuration file.<br/>
 Some tweaking to the cfg are required to achieve an acceptable speed, although trading off some accuracy.<br/>
 Now let's <b>talk about the fun stuff.</b><br/>
</p>
<h2>How does it work? </h2>
<p>The ROS system's architecture is based on one SERVER (in our case the Jetson-TX2) and one or more CLIENTS / NODES (Odroid XU4 or any linux pc).<br/>
 Every client connects to the server sending his planimetry information (his node's ID and his neighbours' IDs) and waits for new instructions to be executed.<br/>
 Client nodes relay on a text file to match the instruction ID received from the server with an actual executable that it can run in a new process. In this way the client side is easy to customize (more on that later...).<br/>
 Every time a client connects to the server, the latter updates the planimetry of the system and communicates the node an "idle" operation that is, in our case study, a <em>Background subtraction</em> process. <br/>
 When a client ends its idle operation, it communicates the termination (and a result, if present) to the server. The server then decides which task to assign to the client. The server also stores all the PID of the processes running on clients. In this way, when necessary, it can tell a client to stop a certain process.</p>
<p><br/>
<br/>
 <b>NB</b>: If you are not into detection and tracking systems, there still is something for you. Just skip the next paragraphs and go to <em>Customizing ROS.</em> <br/>
<br/>
</p>
<div class="image">
<img src="./Concept.svg" />
</div>
<p><em>Icons made by: <a href="https://www.freepik.com/?__hstc=57440181.c2013b29b5d74612c3c8cab36bfc0203.1559675594943.1559675594943.1559847167123.2&amp;__hssc=57440181.2.1559847167123&amp;__hsfp=1353452017">Freepik</a>, <a href="https://www.flaticon.com/authors/photo3idea-studio">photo3idea-studio</a>, <a href="https://www.flaticon.com/authors/eucalyp">eucalyp</a> from www.flaticon.com</em><br/>
</p>
<p><b>NB</b>: As a lot of people don't have multiple cameras at their disposal, we implemented the video stream as a series of images (<a href="https://trac.ffmpeg.org/wiki/Create%20a%20thumbnail%20image%20every%20X%20seconds%20of%20the%20video">https://trac.ffmpeg.org/wiki/Create%20a%20thumbnail%20image%20every%20X%20seconds%20of%20the%20video</a>). <br/>
 <em>Just remember to change FPS and other parameters inside <a class="el" href="classbkgSubtraction.html" title="Instruction to perform background subtraction. ">bkgSubtraction</a> and nodeTracker.</em><br/>
</p>
<h3>Background subtraction</h3>
<p>During this initial phase every client applies background subtraction (provided by OpenCV) to a given video stream.<br/>
 Once a blob that is big enough is detected, the node sends last frame that was analysed to the server to run a first object detection in search of certain user-defined objects.<br/>
 If something is found (inside our project we search for people), a new <em>Tracking</em> instruction is sent to the node that found the blob.<br/>
</p>
<h3>Tracking</h3>
<p>If a client receives this instruction, it starts tracking the defined object that should be in his sight.<br/>
 For every frame that has the object in it, the node saves detected box's coordinates and tries to estimate distance from the camera (with bad results, for now :neutral_face:).<br/>
 When the object is no more in sight of the client's camera, the server receives all saved coordinates and analyse them to decide whether it could keep tracking through other connected cameras.<br/>
 This is possible thanks to the planimetry that is stored inside server.<br/>
</p>
<p><br/>
</p>
<h2>Customizing ROS </h2>
<p>Customization was our focus through the development of the project. <br/>
 The full documentation of our code can be found <a href="https://dpons97.github.io/reimagined-octo-spork/">here</a></p>
<h3>Client-side customization</h3>
<p>As mentioned above, nodes customization is achieved through a map file that associates an ID with a corresponding executable (<b>Client/Executables/executables.txt</b>).<br/>
 When the client receives a message it first checks if it's asking to kill a process or to start a new one.<br/>
 In case it needs to start a new one, it looks up the corresponding executable and parses the parameters (if present). <br/>
 It then opens a new socket connection to bind to the new process. At this point the client forks and the child will start the executable. <br/>
 Eventually the main process communicates the pid of the new task to the server and starts to listen for new instructions again.<br/>
</p>
<p><em>The ClientNode should not need any modifications, it just parses messages and set up the new task.</em><br/>
</p>
<p><b>How to structure new executables:</b><br/>
 New executables always take at least one parameters, the socket with which it communicates with the server. <br/>
 If you want you can add additional parameters. The server will communicate them to the task when sending the execution instruction to the client.</p>
<p>The client could receive a message from the server asking to kill a given pid. In this case ClientNode will send a SIGTERM to the received pid (if it still running). <em>You may want your executables to handle this signal in order to perform a clean exit of the task.</em></p>
<h3>Server-side customization</h3>
<p>Unlike client, ROS Server has to be customized directly from the source code, as it's composed of only one generic class: <b>Instruction.cpp</b> (you can find source code inside <em>Server/Instructions</em>).<br/>
 Basically, an object of type <em><a class="el" href="classInstruction.html" title="Server-side instruction handler. ">Instruction</a></em> is provided with all basic functionalities to communicate with a ClientNode:<br/>
</p>
<ul>
<li>Default initializer: ```cpp <a class="el" href="classInstruction.html" title="Server-side instruction handler. ">Instruction(const string &amp;name, std::map&lt;int, int&gt; &amp;instructions, vector&lt;void*&gt; sharedMemory)</a>; ``` <b>name</b> is, as the name says, a symbolic identifier of the instruction.<br/>
 <b>instructions</b> is a map that contains tuples &lt;pid, socket&gt;. Map key is the client process PID that's running the instruction bound to a specific socket (map value <em>socket</em>).<br/>
 To allow communication between different nodes and instructions inside the same server, a generic optional <b>sharedMemory</b> can be passed as parameter (e.g. planimetry). <em>Remember to cast this to the right data type before using!</em><br/>
 <br/>
</li>
<li>First function to call every time you want to start the instruction is: ```cpp virtual void start(int socket, int port, std::vector&lt;std::string&gt; args); ``` This will let the instruction know which <b>socket</b> and <b>port</b> are bound to this node. <br/>
 Additional arguments (<b>args</b>) can be passed if needed (optional).<br/>
 <br/>
</li>
<li>To send a start signal for a new instruction inside a specific connected node: ```cpp int startInstruction(int instrCode, std::vector&lt;string&gt; args = std::vector&lt;string&gt;()); ``` Where <b>instrCode</b> is the instruction ID you defined inside <em>Client/Executables</em> bound to the relative executable, and <b>args</b> are all arguments you want the node to receive (e.g. inside tracking, the object ID to track is one additional argument passed). <br/>
 The return value is a new socket, which binds server to current node executable.<br/>
 <br/>
</li>
<li>If during the execution of your program you need to receive an image, you can use: ```cpp bool getAnswerImg(int rcvSocket, cv::Mat&amp; outMat); ``` Here <b>rcvSocket</b> is the receving socket (90% of the times it'll be your instruction socket), whereas <b>outMat</b> is a reference to a new OpenCV Mat where the received image will be stored.<br/>
 <br/>
</li>
<li>To stop (or force) a specific instruction and disconnect the relative socket: ```cpp void disconnect(int instrPid = 0); ``` Where <b>instrPid</b> is the instruction node PID (if no pid is defined, all instructions will be closed of this node).<br/>
 <br/>
</li>
</ul>
<p>For additional informations and a code example, feel free to explore this repository. Otherwise, if you have questions or something wasn't clear, you can contact us on GitHub or via email. <br/>
</p>
<h4>Project Contributors:</h4>
<ul>
<li>Luca Collini <a href="https://github.com/Lucaz97"></a> - <a href="#" onclick="location.href='mai'+'lto:'+'luc'+'a.'+'col'+'li'+'ni@'+'ma'+'il.'+'po'+'lim'+'i.'+'it'; return false;">luca.<span style="display: none;">.nosp@m.</span>coll<span style="display: none;">.nosp@m.</span>ini@m<span style="display: none;">.nosp@m.</span>ail.<span style="display: none;">.nosp@m.</span>polim<span style="display: none;">.nosp@m.</span>i.it</a></li>
<li>Davide Pons <a href="https://github.com/DPons97"></a> - <a href="#" onclick="location.href='mai'+'lto:'+'dav'+'id'+'e.p'+'on'+'s@m'+'ai'+'l.p'+'ol'+'imi'+'.i'+'t'; return false;">david<span style="display: none;">.nosp@m.</span>e.po<span style="display: none;">.nosp@m.</span>ns@ma<span style="display: none;">.nosp@m.</span>il.p<span style="display: none;">.nosp@m.</span>olimi<span style="display: none;">.nosp@m.</span>.it</a> <br/>
 </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
